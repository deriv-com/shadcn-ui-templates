const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// ANSI color codes for console output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

// Available shadcn components
const SHADCN_COMPONENTS = [
  'accordion',
  'alert',
  'alert-dialog',
  'aspect-ratio',
  'avatar',
  'badge',
  'breadcrumb',
  'button',
  'calendar',
  'card',
  'carousel',
  'chart',
  'checkbox',
  'collapsible',
  'command',
  'context-menu',
  'data-table',
  'date-picker',
  'dialog',
  'drawer',
  'dropdown-menu',
  'form',
  'hover-card',
  'input',
  'input-otp',
  'label',
  'menubar',
  'navigation-menu',
  'pagination',
  'popover',
  'progress',
  'radio-group',
  'resizable',
  'scroll-area',
  'select',
  'separator',
  'sheet',
  'skeleton',
  'slider',
  'sonner',
  'switch',
  'table',
  'tabs',
  'textarea',
  'toast',
  'toggle',
  'toggle-group',
  'tooltip'
];

function log(message, color = 'white') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function logStep(step, message) {
  log(`[${step}] ${message}`, 'cyan');
}

function logSuccess(message) {
  log(`✅ ${message}`, 'green');
}

function logError(message) {
  log(`❌ ${message}`, 'red');
}

function logWarning(message) {
  log(`⚠️  ${message}`, 'yellow');
}

function ensureDirectoryExists(dirPath) {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
    logStep('CREATE', `Created directory: ${dirPath}`);
  }
}

function getSourcePath(relativePath) {
  // If we're running from dist directory, go up one level
  const currentDir = process.cwd();
  if (currentDir.endsWith('/dist')) {
    return path.join('..', relativePath);
  }
  return relativePath;
}

function copyFile(source, destination) {
  try {
    fs.copyFileSync(source, destination);
    logStep('COPY', `Copied ${path.basename(source)} to ${path.basename(destination)}`);
  } catch (error) {
    logError(`Failed to copy ${source}: ${error.message}`);
    throw error;
  }
}

function copyDirectory(source, destination) {
  try {
    if (fs.existsSync(source)) {
      execSync(`cp -r "${source}" "${destination}"`, { stdio: 'pipe' });
      logStep('COPY', `Copied directory ${path.basename(source)}`);
    }
  } catch (error) {
    logError(`Failed to copy directory ${source}: ${error.message}`);
    throw error;
  }
}

function generateComponentIndex() {
  const componentsDir = path.join(process.cwd(), 'npm-dist', 'components');
  const indexPath = path.join(componentsDir, 'index.ts');
  
  let indexContent = `// Auto-generated component index
// This file is automatically generated by the build script

`;

  // Add all component exports
  SHADCN_COMPONENTS.forEach(component => {
    const componentPath = path.join(componentsDir, component);
    if (fs.existsSync(componentPath)) {
      indexContent += `export * from './${component}';\n`;
    }
  });

  fs.writeFileSync(indexPath, indexContent);
  logStep('GENERATE', 'Generated component index.ts');
}

function copyAndUpdatePackageJson() {
  const distPath = path.join(process.cwd(), 'npm-dist');
  const sourcePackageJsonPath = path.join(process.cwd(), 'package.json');
  const destPackageJsonPath = path.join(distPath, 'package.json');
  
  // Read the existing package.json
  const packageJson = JSON.parse(fs.readFileSync(sourcePackageJsonPath, 'utf8'));
  
  // Update only the necessary fields for npm publishing
  const updatedPackageJson = {
    ...packageJson,
    name: '@deriv/shadcn-components',
    description: 'Deriv Quill shadcn/ui components with Figma design token integration',
    main: 'index.js',
    module: 'index.esm.js',
    types: 'index.d.ts',
    exports: {
      ".": {
        "import": "./index.esm.js",
        "require": "./index.js",
        "types": "./index.d.ts"
      },
      "./styles": "./styles/globals.css",
      "./tailwind": "./tailwind.config.js"
    },
    publishConfig: {
      access: 'public',
      registry: 'https://registry.npmjs.org'
    },
    files: [
      "index.js",
      "index.esm.js", 
      "index.d.ts",
      "components/",
      "lib/",
      "styles/",
      "types/",
      "tailwind.config.js",
      "postcss.config.js",
      "README.md",
      "CHANGELOG.md"
    ],
    // Remove dev scripts and keep only what's needed for the package
    scripts: {
      build: 'node scripts/build-components.js',
      prepublishOnly: 'npm run build'
    }
  };
  
  fs.writeFileSync(destPackageJsonPath, JSON.stringify(updatedPackageJson, null, 2));
  logStep('COPY', 'Copied and updated package.json for npm package');
}

function generateReadme() {
  const readmeContent = `# @deriv/shadcn-components

Deriv's shadcn/ui components with Figma design token integration.

## Installation

\`\`\`bash
npm install @deriv/shadcn-components
\`\`\`

## Setup

### 1. Install Dependencies

Make sure you have the required peer dependencies:

\`\`\`bash
npm install react react-dom
\`\`\`

### 2. Import Styles

Add the CSS to your app:

\`\`\`tsx
// In your main.tsx or App.tsx
import '@deriv/shadcn-components/styles';
\`\`\`

### 3. Configure Tailwind (Optional)

If you want to use the included Tailwind config:

\`\`\`js
// tailwind.config.js
import tailwindConfig from '@deriv/shadcn-components/tailwind';

export default {
  ...tailwindConfig,
  // your custom config
};
\`\`\`

## Usage

\`\`\`tsx
import { Button, Card, Input } from '@deriv/shadcn-components';

function App() {
  return (
    <Card>
      <Input placeholder="Enter your name" />
      <Button>Click me</Button>
    </Card>
  );
}
\`\`\`

## Components

This package includes all shadcn/ui components with Deriv's design token integration:

- **Layout**: Accordion, Card, Collapsible, Separator, Sheet, Tabs
- **Forms**: Button, Checkbox, Input, Label, Radio Group, Select, Switch, Textarea
- **Navigation**: Breadcrumb, Dropdown Menu, Menubar, Navigation Menu, Pagination
- **Feedback**: Alert, Alert Dialog, Dialog, Hover Card, Popover, Toast, Tooltip
- **Data Display**: Avatar, Badge, Calendar, Progress, Skeleton, Table
- **Overlay**: Command, Context Menu, Drawer, Resizable, Scroll Area, Slider
- **And many more...**

## Design Tokens

All components use Deriv's Figma design tokens for consistent styling across all Deriv products. The design tokens are automatically applied and include:

- **Colors**: Primary, secondary, accent, destructive, muted, and custom Deriv colors
- **Typography**: Font families, sizes, weights, and line heights
- **Spacing**: Consistent spacing scale
- **Borders**: Radius and border styles
- **Shadows**: Elevation and depth

## TypeScript Support

Full TypeScript support with comprehensive type definitions for all components.

## License

MIT
`;

  const distPath = path.join(process.cwd(), 'npm-dist');
  const readmePath = path.join(distPath, 'README.md');
  
  fs.writeFileSync(readmePath, readmeContent);
  logStep('GENERATE', 'Generated README.md for npm package');
}

function generateChangelog() {
  const changelogContent = `# Changelog

All notable changes to this project will be documented in this file.

## [1.0.0] - ${new Date().toISOString().split('T')[0]}

### Added
- Initial release of @deriv/shadcn-components
- All shadcn/ui components with Deriv design token integration
- Figma design token support
- TypeScript definitions
- Comprehensive component library

### Components
- Accordion
- Alert
- Alert Dialog
- Avatar
- Badge
- Button
- Card
- Checkbox
- Dialog
- Dropdown Menu
- Form
- Input
- Label
- Popover
- Select
- Sheet
- Switch
- Table
- Tabs
- Toast
- Tooltip
- And many more...

## [0.1.0] - ${new Date().toISOString().split('T')[0]}

### Added
- Initial development version
- Basic component structure
- Design token integration
`;

  const distPath = path.join(process.cwd(), 'npm-dist');
  const changelogPath = path.join(distPath, 'CHANGELOG.md');
  
  fs.writeFileSync(changelogPath, changelogContent);
  logStep('GENERATE', 'Generated CHANGELOG.md for npm package');
}

async function compileTypeScript(distPath) {
  try {
    // Create a simple TypeScript compilation using tsc
    const { execSync } = require('child_process');
    
    // Create a temporary tsconfig.json for the build
    const tsconfig = {
      compilerOptions: {
        target: 'ES2020',
        lib: ['ES2020', 'DOM', 'DOM.Iterable'],
        module: 'ESNext',
        moduleResolution: 'bundler',
        resolveJsonModule: true,
        isolatedModules: true,
        noEmit: false,
        jsx: 'react-jsx',
        strict: true,
        noUnusedLocals: true,
        noUnusedParameters: true,
        noFallthroughCasesInSwitch: true,
        outDir: './',
        declaration: true,
        declarationMap: true,
        sourceMap: true
      },
      include: ['components/**/*', 'lib/**/*', 'types/**/*', 'index.ts'],
      exclude: ['node_modules', 'dist']
    };

    const tsconfigPath = path.join(distPath, 'tsconfig.json');
    fs.writeFileSync(tsconfigPath, JSON.stringify(tsconfig, null, 2));

    // Compile TypeScript
    execSync('npx tsc', { 
      cwd: distPath, 
      stdio: 'inherit' 
    });

    logStep('COMPILE', 'TypeScript compilation completed');
  } catch (error) {
    logWarning(`TypeScript compilation failed: ${error.message}`);
    logWarning('Continuing with TypeScript files only...');
  }
}

async function buildComponents() {
  try {
    log('🚀 Starting component build process...', 'bright');
    log('', 'white');

    // Step 1: Clean and create npm-dist directory
    logStep('CLEAN', 'Cleaning npm-dist directory...');
    const distPath = path.join(process.cwd(), 'npm-dist');
    if (fs.existsSync(distPath)) {
      fs.rmSync(distPath, { recursive: true, force: true });
    }
    ensureDirectoryExists(distPath);

    // Step 2: Copy source components
    logStep('COPY', 'Copying source components...');
    const srcComponentsPath = path.join(process.cwd(), getSourcePath('src'), 'components');
    const distComponentsPath = path.join(distPath, 'components');
    
    if (fs.existsSync(srcComponentsPath)) {
      copyDirectory(srcComponentsPath, distComponentsPath);
    } else {
      logWarning('Source components directory not found, creating empty structure...');
      ensureDirectoryExists(distComponentsPath);
    }

    // Step 3: Copy lib utilities
    logStep('COPY', 'Copying lib utilities...');
    const srcLibPath = path.join(process.cwd(), getSourcePath('src'), 'lib');
    const distLibPath = path.join(distPath, 'lib');
    
    if (fs.existsSync(srcLibPath)) {
      copyDirectory(srcLibPath, distLibPath);
    } else {
      logWarning('Source lib directory not found, creating empty structure...');
      ensureDirectoryExists(distLibPath);
    }

    // Step 4: Copy styles
    logStep('COPY', 'Copying styles...');
    const srcStylesPath = path.join(process.cwd(), getSourcePath('src'), 'styles');
    const distStylesPath = path.join(distPath, 'styles');
    
    if (fs.existsSync(srcStylesPath)) {
      copyDirectory(srcStylesPath, distStylesPath);
    } else {
      logWarning('Source styles directory not found, creating empty structure...');
      ensureDirectoryExists(distStylesPath);
    }

    // Step 5: Copy types
    logStep('COPY', 'Copying types...');
    const srcTypesPath = path.join(process.cwd(), getSourcePath('src'), 'types');
    const distTypesPath = path.join(distPath, 'types');
    
    if (fs.existsSync(srcTypesPath)) {
      copyDirectory(srcTypesPath, distTypesPath);
    } else {
      logWarning('Source types directory not found, creating empty structure...');
      ensureDirectoryExists(distTypesPath);
    }

    // Step 6: Copy configuration files
    logStep('COPY', 'Copying configuration files...');
    const configFiles = [
      'components.json',
      'tailwind.config.js',
      'postcss.config.js'
    ];

    configFiles.forEach(file => {
      const sourcePath = path.join(process.cwd(), getSourcePath(file));
      const destPath = path.join(distPath, file);
      if (fs.existsSync(sourcePath)) {
        copyFile(sourcePath, destPath);
      }
    });

    // Step 7: Copy registry
    logStep('COPY', 'Copying registry...');
    const srcRegistryPath = path.join(process.cwd(), getSourcePath('registry'));
    const distRegistryPath = path.join(distPath, 'registry');
    
    if (fs.existsSync(srcRegistryPath)) {
      copyDirectory(srcRegistryPath, distRegistryPath);
    }

    // Step 8: Copy override tokens
    logStep('COPY', 'Copying design tokens...');
    const srcOverridePath = path.join(process.cwd(), getSourcePath('override'));
    const distOverridePath = path.join(distPath, 'override');
    
    if (fs.existsSync(srcOverridePath)) {
      copyDirectory(srcOverridePath, distOverridePath);
    }

    // Step 9: Copy scripts
    logStep('COPY', 'Copying build scripts...');
    const srcScriptsPath = path.join(process.cwd(), getSourcePath('scripts'));
    const distScriptsPath = path.join(distPath, 'scripts');
    
    if (fs.existsSync(srcScriptsPath)) {
      copyDirectory(srcScriptsPath, distScriptsPath);
    }

    // Step 10: Generate component index
    logStep('GENERATE', 'Generating component index...');
    generateComponentIndex();

    // Step 11: Copy and update package.json
    logStep('COPY', 'Copying and updating package.json...');
    copyAndUpdatePackageJson();

    // Step 12: Generate README
    logStep('GENERATE', 'Generating README.md...');
    generateReadme();

    // Step 13: Generate CHANGELOG
    logStep('GENERATE', 'Generating CHANGELOG.md...');
    generateChangelog();

    // Step 14: Generate main index file
    logStep('GENERATE', 'Generating main index file...');
    const mainIndexContent = `// Main entry point for @deriv/shadcn-components
export * from './components';
export * from './lib';
export * from './types';
`;
    fs.writeFileSync(path.join(distPath, 'index.ts'), mainIndexContent);

    // Step 15: Compile TypeScript to JavaScript
    logStep('COMPILE', 'Compiling TypeScript to JavaScript...');
    await compileTypeScript(distPath);

    log('', 'white');
    logSuccess('Component build completed successfully!');
    log('', 'white');
    log('📦 Build output:', 'bright');
    log(`   📁 npm-dist/`, 'white');
    log(`   ├── components/`, 'white');
    log(`   ├── lib/`, 'white');
    log(`   ├── styles/`, 'white');
    log(`   ├── types/`, 'white');
    log(`   ├── registry/`, 'white');
    log(`   ├── override/`, 'white');
    log(`   ├── scripts/`, 'white');
    log(`   ├── package.json`, 'white');
    log(`   ├── README.md`, 'white');
    log(`   ├── CHANGELOG.md`, 'white');
    log(`   └── index.ts`, 'white');
    log('', 'white');
    log('🚀 Ready for npm publishing!', 'green');

  } catch (error) {
    logError(`Build failed: ${error.message}`);
    process.exit(1);
  }
}

// Run the build if this script is executed directly
if (require.main === module) {
  buildComponents();
}

module.exports = { buildComponents };
