const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// ANSI color codes for console output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

// Available shadcn components
const SHADCN_COMPONENTS = [
  'accordion',
  'alert',
  'alert-dialog',
  'aspect-ratio',
  'avatar',
  'badge',
  'breadcrumb',
  'button',
  'calendar',
  'card',
  'carousel',
  'chart',
  'checkbox',
  'collapsible',
  'command',
  'context-menu',
  'data-table',
  'date-picker',
  'dialog',
  'drawer',
  'dropdown-menu',
  'form',
  'hover-card',
  'input',
  'input-otp',
  'label',
  'menubar',
  'navigation-menu',
  'pagination',
  'popover',
  'progress',
  'radio-group',
  'resizable',
  'scroll-area',
  'select',
  'separator',
  'sheet',
  'skeleton',
  'slider',
  'sonner',
  'switch',
  'table',
  'tabs',
  'textarea',
  'toast',
  'toggle',
  'toggle-group',
  'tooltip'
];

function log(message, color = 'white') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function logStep(step, message) {
  log(`[${step}] ${message}`, 'cyan');
}

function logSuccess(message) {
  log(`✅ ${message}`, 'green');
}

function logError(message) {
  log(`❌ ${message}`, 'red');
}

function logWarning(message) {
  log(`⚠️  ${message}`, 'yellow');
}

function ensureDirectoryExists(dirPath) {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
    logStep('CREATE', `Created directory: ${dirPath}`);
  }
}

function copyFile(source, destination) {
  try {
    fs.copyFileSync(source, destination);
    logStep('COPY', `Copied ${path.basename(source)} to ${path.basename(destination)}`);
  } catch (error) {
    logError(`Failed to copy ${source}: ${error.message}`);
    throw error;
  }
}

function copyDirectory(source, destination) {
  try {
    if (fs.existsSync(source)) {
      execSync(`cp -r "${source}" "${destination}"`, { stdio: 'pipe' });
      logStep('COPY', `Copied directory ${path.basename(source)}`);
    }
  } catch (error) {
    logError(`Failed to copy directory ${source}: ${error.message}`);
    throw error;
  }
}

function generateComponentIndex() {
  const componentsDir = path.join(process.cwd(), 'dist', 'components');
  const indexPath = path.join(componentsDir, 'index.ts');
  
  let indexContent = `// [AI]
// Auto-generated component index
// This file is automatically generated by the build script

`;

  // Add all component exports
  SHADCN_COMPONENTS.forEach(component => {
    const componentPath = path.join(componentsDir, component);
    if (fs.existsSync(componentPath)) {
      indexContent += `export * from './${component}';\n`;
    }
  });

  fs.writeFileSync(indexPath, indexContent);
  logStep('GENERATE', 'Generated component index.ts');
}

function generatePackageJson() {
  const packageJson = {
    name: '@deriv/shadcn-components',
    version: '1.0.0',
    description: 'Deriv Quill shadcn/ui components with Figma design token integration',
    main: 'dist/index.js',
    module: 'dist/index.esm.js',
    types: 'dist/index.d.ts',
    publishConfig: {
      access: 'public',
      registry: 'https://registry.npmjs.org'
    },
    files: [
      'dist',
      'README.md',
      'CHANGELOG.md'
    ],
    scripts: {
      build: 'node scripts/build-components.js',
      prepublishOnly: 'npm run build'
    },
    keywords: [
      'shadcn',
      'ui',
      'components',
      'react',
      'typescript',
      'tailwind',
      'deriv',
      'figma',
      'design-tokens'
    ],
    author: 'Deriv',
    license: 'MIT',
    peerDependencies: {
      'react': '^18.0.0',
      'react-dom': '^18.0.0'
    },
    dependencies: {
      '@radix-ui/react-accordion': '^1.1.2',
      '@radix-ui/react-alert-dialog': '^1.0.5',
      '@radix-ui/react-aspect-ratio': '^1.0.3',
      '@radix-ui/react-avatar': '^1.0.4',
      '@radix-ui/react-checkbox': '^1.0.4',
      '@radix-ui/react-collapsible': '^1.0.3',
      '@radix-ui/react-dialog': '^1.0.5',
      '@radix-ui/react-dropdown-menu': '^2.0.6',
      '@radix-ui/react-hover-card': '^1.0.7',
      '@radix-ui/react-label': '^2.0.2',
      '@radix-ui/react-menubar': '^1.0.4',
      '@radix-ui/react-navigation-menu': '^1.1.4',
      '@radix-ui/react-popover': '^1.0.7',
      '@radix-ui/react-progress': '^1.0.3',
      '@radix-ui/react-radio-group': '^1.1.3',
      '@radix-ui/react-scroll-area': '^1.0.5',
      '@radix-ui/react-select': '^2.0.0',
      '@radix-ui/react-separator': '^1.0.3',
      '@radix-ui/react-slider': '^1.1.2',
      '@radix-ui/react-switch': '^1.0.3',
      '@radix-ui/react-tabs': '^1.0.4',
      '@radix-ui/react-toast': '^1.1.5',
      '@radix-ui/react-toggle': '^1.0.3',
      '@radix-ui/react-toggle-group': '^1.0.4',
      '@radix-ui/react-tooltip': '^1.0.7',
      'class-variance-authority': '^0.7.0',
      'clsx': '^2.0.0',
      'lucide-react': '^0.294.0',
      'tailwind-merge': '^2.0.0',
      'tailwindcss-animate': '^1.0.7'
    },
    devDependencies: {
      '@types/react': '^18.2.0',
      '@types/react-dom': '^18.2.0',
      'typescript': '^5.0.0'
    }
  };

  const distPath = path.join(process.cwd(), 'dist');
  const packageJsonPath = path.join(distPath, 'package.json');
  
  fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
  logStep('GENERATE', 'Generated package.json for npm package');
}

function generateReadme() {
  const readmeContent = `# [AI]
# @deriv/shadcn-components

Deriv's shadcn/ui components with Figma design token integration.

## Installation

\`\`\`bash
npm install @deriv/shadcn-components
\`\`\`

## Usage

\`\`\`tsx
import { Button } from '@deriv/shadcn-components';

function App() {
  return <Button>Click me</Button>;
}
\`\`\`

## Components

This package includes all shadcn/ui components with Deriv's design token integration:

- Accordion
- Alert
- Alert Dialog
- Avatar
- Badge
- Button
- Card
- Checkbox
- Dialog
- Dropdown Menu
- Form
- Input
- Label
- Popover
- Select
- Sheet
- Switch
- Table
- Tabs
- Toast
- Tooltip
- And many more...

## Design Tokens

All components use Deriv's Figma design tokens for consistent styling across all Deriv products.

## License

MIT
# [/AI]
`;

  const distPath = path.join(process.cwd(), 'dist');
  const readmePath = path.join(distPath, 'README.md');
  
  fs.writeFileSync(readmePath, readmeContent);
  logStep('GENERATE', 'Generated README.md for npm package');
}

function generateChangelog() {
  const changelogContent = `# [AI]
# Changelog

All notable changes to this project will be documented in this file.

## [1.0.0] - ${new Date().toISOString().split('T')[0]}

### Added
- Initial release of @deriv/shadcn-components
- All shadcn/ui components with Deriv design token integration
- Figma design token support
- TypeScript definitions
- Comprehensive component library

### Components
- Accordion
- Alert
- Alert Dialog
- Avatar
- Badge
- Button
- Card
- Checkbox
- Dialog
- Dropdown Menu
- Form
- Input
- Label
- Popover
- Select
- Sheet
- Switch
- Table
- Tabs
- Toast
- Tooltip
- And many more...

## [0.1.0] - ${new Date().toISOString().split('T')[0]}

### Added
- Initial development version
- Basic component structure
- Design token integration
# [/AI]
`;

  const distPath = path.join(process.cwd(), 'dist');
  const changelogPath = path.join(distPath, 'CHANGELOG.md');
  
  fs.writeFileSync(changelogPath, changelogContent);
  logStep('GENERATE', 'Generated CHANGELOG.md for npm package');
}

async function buildComponents() {
  try {
    log('🚀 Starting component build process...', 'bright');
    log('', 'white');

    // Step 1: Clean and create dist directory
    logStep('CLEAN', 'Cleaning dist directory...');
    const distPath = path.join(process.cwd(), 'dist');
    if (fs.existsSync(distPath)) {
      fs.rmSync(distPath, { recursive: true, force: true });
    }
    ensureDirectoryExists(distPath);

    // Step 2: Copy source components
    logStep('COPY', 'Copying source components...');
    const srcComponentsPath = path.join(process.cwd(), 'src', 'components');
    const distComponentsPath = path.join(distPath, 'components');
    
    if (fs.existsSync(srcComponentsPath)) {
      copyDirectory(srcComponentsPath, distComponentsPath);
    } else {
      logWarning('Source components directory not found, creating empty structure...');
      ensureDirectoryExists(distComponentsPath);
    }

    // Step 3: Copy lib utilities
    logStep('COPY', 'Copying lib utilities...');
    const srcLibPath = path.join(process.cwd(), 'src', 'lib');
    const distLibPath = path.join(distPath, 'lib');
    
    if (fs.existsSync(srcLibPath)) {
      copyDirectory(srcLibPath, distLibPath);
    } else {
      logWarning('Source lib directory not found, creating empty structure...');
      ensureDirectoryExists(distLibPath);
    }

    // Step 4: Copy styles
    logStep('COPY', 'Copying styles...');
    const srcStylesPath = path.join(process.cwd(), 'src', 'styles');
    const distStylesPath = path.join(distPath, 'styles');
    
    if (fs.existsSync(srcStylesPath)) {
      copyDirectory(srcStylesPath, distStylesPath);
    } else {
      logWarning('Source styles directory not found, creating empty structure...');
      ensureDirectoryExists(distStylesPath);
    }

    // Step 5: Copy types
    logStep('COPY', 'Copying types...');
    const srcTypesPath = path.join(process.cwd(), 'src', 'types');
    const distTypesPath = path.join(distPath, 'types');
    
    if (fs.existsSync(srcTypesPath)) {
      copyDirectory(srcTypesPath, distTypesPath);
    } else {
      logWarning('Source types directory not found, creating empty structure...');
      ensureDirectoryExists(distTypesPath);
    }

    // Step 6: Copy configuration files
    logStep('COPY', 'Copying configuration files...');
    const configFiles = [
      'components.json',
      'tailwind.config.js',
      'postcss.config.js'
    ];

    configFiles.forEach(file => {
      const sourcePath = path.join(process.cwd(), file);
      const destPath = path.join(distPath, file);
      if (fs.existsSync(sourcePath)) {
        copyFile(sourcePath, destPath);
      }
    });

    // Step 7: Copy registry
    logStep('COPY', 'Copying registry...');
    const srcRegistryPath = path.join(process.cwd(), 'registry');
    const distRegistryPath = path.join(distPath, 'registry');
    
    if (fs.existsSync(srcRegistryPath)) {
      copyDirectory(srcRegistryPath, distRegistryPath);
    }

    // Step 8: Copy override tokens
    logStep('COPY', 'Copying design tokens...');
    const srcOverridePath = path.join(process.cwd(), 'override');
    const distOverridePath = path.join(distPath, 'override');
    
    if (fs.existsSync(srcOverridePath)) {
      copyDirectory(srcOverridePath, distOverridePath);
    }

    // Step 9: Copy scripts
    logStep('COPY', 'Copying build scripts...');
    const srcScriptsPath = path.join(process.cwd(), 'scripts');
    const distScriptsPath = path.join(distPath, 'scripts');
    
    if (fs.existsSync(srcScriptsPath)) {
      copyDirectory(srcScriptsPath, distScriptsPath);
    }

    // Step 10: Generate component index
    logStep('GENERATE', 'Generating component index...');
    generateComponentIndex();

    // Step 11: Generate package.json
    logStep('GENERATE', 'Generating package.json...');
    generatePackageJson();

    // Step 12: Generate README
    logStep('GENERATE', 'Generating README.md...');
    generateReadme();

    // Step 13: Generate CHANGELOG
    logStep('GENERATE', 'Generating CHANGELOG.md...');
    generateChangelog();

    // Step 14: Generate main index file
    logStep('GENERATE', 'Generating main index file...');
    const mainIndexContent = `// [AI]
// Main entry point for @deriv/shadcn-components
export * from './components';
export * from './lib';
export * from './types';
# [/AI]
`;
    fs.writeFileSync(path.join(distPath, 'index.ts'), mainIndexContent);

    log('', 'white');
    logSuccess('Component build completed successfully!');
    log('', 'white');
    log('📦 Build output:', 'bright');
    log(`   📁 dist/`, 'white');
    log(`   ├── components/`, 'white');
    log(`   ├── lib/`, 'white');
    log(`   ├── styles/`, 'white');
    log(`   ├── types/`, 'white');
    log(`   ├── registry/`, 'white');
    log(`   ├── override/`, 'white');
    log(`   ├── scripts/`, 'white');
    log(`   ├── package.json`, 'white');
    log(`   ├── README.md`, 'white');
    log(`   ├── CHANGELOG.md`, 'white');
    log(`   └── index.ts`, 'white');
    log('', 'white');
    log('🚀 Ready for npm publishing!', 'green');

  } catch (error) {
    logError(`Build failed: ${error.message}`);
    process.exit(1);
  }
}

// Run the build if this script is executed directly
if (require.main === module) {
  buildComponents();
}

module.exports = { buildComponents };
